---
title: 设计模式综述
date: 2020-07-18
updated: 2020-07-18
category:
  - 计算机科学
  - 设计模式
tags:
  - 软件架构
  - 设计模式
keywords: 设计模式
---

### 设计模式分类

GoF 将软件设计中常用的模式分为三类：

|类型|目的|类模式|对象模式|
|:---:|:---:|:---:|:---:|
|创建型模式|怎样创建对象，分离创建与使用过程|工厂方法|单例、原型、创建者、抽象工厂|
|结构型模式|对象怎样组合成更大的布局结构|（类）适配器|代理、（对象）适配器、桥接、装饰、外观、享元、组合|
|行为型模式|对象之间怎样协同、分配责任|模板方法、解释器|策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录|

### 创建型模式

#### Factory Method 工厂方法模式

在父子层级的类结构关系中，接口定义了创建关联类实例的方法，具体方法由子类实现。如应用框架 Application 在具体使用环境有绘图应用子类 DrawingApplication，应用对象关联着文档对象 Document 实例，绘图应用中即文档子类 DrawingDocument。工厂方法指 Application、DrawingApplication 有 createDocument 方法用于文档对象，DrawingApplication 子类会创建 DrawingDocument 实例。其与接口相似，父类在实现编程接口时就不必关心关联的实例由哪个具体类实现。同时，由子类实现具体的方法，就可以在方法实现中添加 hooks（即模板方法）。

工厂方法不限于类或者父子类层级结构，也可以在模块中直接导出。

#### Abstract Factory 抽象工厂模式

抽象工厂提供创建一系列部件的接口，即抽象工厂的具体实现类可以生产不同风格的部件。如组件工厂 WidgetFactory 可以生产 ScrollBar 滚动条、Button 按钮等组件，即 WidgetFactory 包含 createScrollBar、createButton 等方法。具体的工厂可以生产不同风格的组件库，如 MotifWidgetFactory#createScrollBar 可用于生产 Motif 风格的组件，PMWidgetFactory#createScrollBar 可用于生产 Presentation Manager 风格的滚动条。通过接口衔接，抽象工厂易于切换不同风格的组件。抽象工厂模式中，创建部件的方法通常通过工厂模式实现；具体工厂通常基于单例模式实现。

#### Builder 建造者模式

以组装的方式构建复杂对象。与抽象工厂方法不同点在于，抽象工厂的目的聚焦于生产作为成品的部件，建造者的目的在于将不构成成品的部件复合成成品的复杂对象。在抽象建造者和具体建造者两个层级中，不同的具体建造者可以实现不同的部件，以使两类成品有各自的表现。GoF 的设计模式将阅读器处理文档内容也视为应用了建造者模式。文档内容经语法分析后，会由不同的文本转换器处理不同类型的语法，或绘制普通文本，或绘制可编辑内容等。普通文本和可编辑内容等构成了文档这个复杂对象，直觉上，这种处理方式难于被理解为创建型模式。

#### Singleton 单例模式

单例模式须保证一个类在全局环境中仅有一个实例，并为它提供一个全局访问点。如浏览器框架中的 window 实例，window 中的 document 实例，应用中的线程池、全局缓存，以及上文说的具体工厂等。其拓展为有限多列模式。创建单例的方式可以由类自身提供 Singleton#getInstance 方法实现，这样可以避免创建其他实例。如果想要对实例进行扩展，可以在子类中进行扩展。

#### Prototype 原型模式

以一个实例作为创建新对象的原型，即可以通过拷贝的方式进行创建。这操作本身如 web 应用中复制某活动、某流程等。GoF 的设计模式一书讨论了扩展图形编辑器以支持绘制乐谱的功能。在扩展的过程中，图形编辑器需要添加可选择、移动、操纵的音符、休止符和五线谱等工具 GraphicTool 实例，这既可以通过制作 GraphicTool 子类实现，又可以通过原型模式拷贝原有的 GraphicTool 实例实现。使用原型模式可以尽可能地复用原有的表现和功能。

#### 创建型模式回顾

假想有一家生产汽车的厂商，生产汽车有其标准、规格（接口规范），有海外代工厂，有汽车零部件，有流水线组装工厂。以汽车生产类比不同的创建型模式，其对比如下：

|模式|类比|
|:---:|:---:|
|工厂方法模式|由海外代工厂生产汽车，节省母厂的组织管理成本|
|抽象工厂模式|描述整车有哪些零部件构成，不同的汽车有不同风格的零部件|
|建造者模式|汽车零部件经流水线组装成整车|
|单例模式|汽车品牌、整车型号等只有一个|
|原型模式|超现代手段复制整车，以避免复杂的生产流水|

### 结构型模式

#### Facade 外观模式

当系统由多模块构成，使用外观与外部系统进行交互，这样可以有规整的接口描述，也可以避免外部系统直接与模块对接造成的过耦合（即外部系统不需要感知本系统的实现）。避免了过耦合，也有利于在两方约定的接口之外，对模块的实现作演进。

#### Adapter 适配器模式

通过适配器模式，能将第三方接口或对象转变成本系统内的接口或对象编码模式，即兼容第三方接口。试想富文本编辑器组件想要在 antd 表单环境中使用时，就需要使用适配器模式为其对接 props.value、props.onChange，以使数据流能在富文本编辑器组件和表单实例中流通。适配器模式有便于在现行的应用环境中使用已有的第三方类库。除了单向适配器外，还有双向适配器。

#### Decorator 装饰者模式

装饰者模式也称为 Wrapper 包装器模式，指通过外嵌对象为内部对象添加一些功能。外嵌对象涵盖内嵌对象的全量接口，因此可以无修改代码地使用装饰器。GoF 讨论了 ScrollDecorator 装饰器能为 TextView 文本框追加滚动功能。前端的高阶组件也用于在被包裹的组件上实现特定的功能，比如 react-router-dom 的 withRouter 方法能为组件注入 location 等信息。装饰器相较于使用子类添加功能更为灵活。

#### Proxy 代理模式

使用代理模式可桥接对实际对象的访问，因此在代理过程中，可附加如请求处理、权限校验等间接性操作。部分效果同装饰者模式。

#### Bridge 桥接模式

通常类按抽象类定义的标准实现，当抽象类由多个类继承时，改变接口规范就要调整那一个抽象类以及相关的多个实现类。桥接模式通过抽象类反向持有实现类实例达成。在 GoF 的设计模式中，Window 抽象类持有 WindowImpl 实现类实例，并调用实现类实例的方法达成其功能。无论抽象类 Abstraction 还是实现类 Implementor，都可能具有嵌套的多层次结构。

以便于理解的方式讲，不同的实现类譬如不同的工具，抽象类譬如要达成的效果，抽象类持有实现类实例即使用工具达成某种效果。

#### Composite 组合模式

以树形结构描述“部分-整体”的层次关系，并使“部分”和“整体”持有相同的接口，这样便于作无差别的递归处理。GoF 讨论了图形编辑器，Text、Line 等作为实际绘制内容的图元，Row 等作为绘制图元的容器。使用组合模式后，容器类和图元类都会有操纵树节点的接口（add、remove、getChildren 等），即可普遍地应用树的处理机制。容器的 draw 操作可递归调用图元的 draw 操作。与树不同的是，图元肯定是叶子节点。组合模式在语法分析、浏览器 DOM 节点、前端组件中都由广泛应用。

在现实生活中，组织结构通常有树的特征，组合模式就对应于上级将任务分派给实际处理事务的下级，这样建模也便于添加管理节点。

#### Flyweight 享元模式

当大量对象可以用有限种内部状态进行标识，为了避免内存上的消耗，就可以对这有限种内部状态进行分类，以构建数目同样有限的对象，通过传递外部状态来复用这些对象。享元模式适用于不必持久化的中间处理过程或需要限制内存使用的场景，如文档分析时可使用享元模式处理读取到的字符，这时创建的对象就不是文档包含的总字符数，而是字符或其所用颜色的组合类目数。享元模式在对象池、http 连接池、数据库连接池中均有使用。

#### 结构型模式回顾

|模式|类比|
|:---:|:---:|
|外观模式|一家人有一个账面|
|适配器模式|电源适配器为手提设备转换电压电流|
|装饰器模式|枪管上添加消声器|
|代理模式|消息有代理人美化并传达|
|桥接模式|一般生产物件须符合规格，这里按规格寻找物件，或者按效果寻找工具|
|组合模式|组织结构中的消息可送达，管理节点可添加、可删除、可查找|
|享元模式|没有更换记账方法，就可以在老账簿中记录今天的收入支出情况|

### 行为模式

#### Template Method 模板方法模式

模板方法模式指父类定义算法逻辑骨架，由子类提供具体逻辑步骤的实现（即算法中调用的方法）。GoF 中提到，抽象类 Application 应用框架中包含 openDocument 方法用于打开文档，其执行过程定义了逻辑骨架，即会逐步调用 canOpenDocument、doCreateDocument、aboutToOpenDocument 等方法。这些被调用的方法会在 Application 的具体子类如 DrawApplication、SpreadsheetApplication 中实现。

#### Mediator 中介者模式

中介模式使用一个中介对象封装一组对象交互，以避免这些对象之间的复杂通信。各对象因为中介者的存在而不需要显式地相互引用，这样的松耦合也便于独立地改变它们之间的交互形态。试想状态管理器或 form store 对于表单联动的作用，如果没有这样的中介者，各表单控件对象就无可避免会有错综的交互关系。

#### Interator 迭代器模式

迭代器模式提供一种顺序访问聚合对象中各元素的方法，同时不需要暴露该聚合对象的内部表示。基于迭代器模式，你可以实现具体的遍历操作。如 Java 的实现，迭代器 ListIterator 会在迭代对象 List 外独立实现，同时迭代对象 List 又可以通过工厂方法创建具体的迭代器。迭代对象不止于列表，也包含嵌套树结构。迭代器须实现的最小接口为 first、next、isDone、currentItem。

#### Chain Of Responsibil 职责链模式

职责链模式将请求的处理对象构造为链式结构，然后在这条链上依序传递请求，直到请求被某个对象处理，或者最终得不到处理。处理节点可添加，也可删除。职责链既可以实现为函数队列，也可以实现为流程节点，在处理时调用流程节点的 handle 方法。职责链模式应用于 servelt 过滤器，redux、koa 中间件，以及 koa-router 路由的实现。

#### Memento 备完录模式

备完录模式指在不破坏封装性的前提下，捕获并记录一个对象的内部状态变更信息，以便支持撤销操作，恢复该对象原有的状态。不破坏封装性指的是，由负责状态变更的原发器向备完录中创建一条信息变更记录，后续也只有原发器能访问这条记录，不允许其他对象访问。

#### Observer 观察者模式

观察者模式也称为发布-订阅模式。当主题对象的状态发生变更时，就会发送消息给订阅这些主题的观察者，促使它们执行后续动作。其一般意义在于，在一对多的依赖关系中，当依赖（dependence）更新时，所有依赖于它的对象（dependent）都会自动接收通知，并启用后续的处理流程。观察者模式的应用见于前端的事件系统、redis 等消息中中间件。

#### Command 命令模式

命令模式又称为 Action 或 Transactio。它通过将请求封装为命令对象，因此可以让系统参数化处理请求，包含排队、日志、撤回功能。与过程化的请求调用不同，命令对象在程序中会有更长的生命周期，我们可以在程序运行的任意时刻访问命令对象，且命令对象可以被四处传递。命令对象能将请求的发送者和请求的接收者与请求本身解耦。其实现可大可小，命令对象可以包含接收者的行为逻辑，也可以将请求转发给接收者。程序实现上，也可以将多个命令组合成宏命令。

#### State 状态模式

状态模式以状态变更组织逻辑周转流程。状态对象的实现可重可轻，既可以将状态变更后的行为封装在状态对象中，也可以通过上下文对象根据新的状态值触发后续的行为。个中的关联就像应用管理中的审批状态以及由该状态影响的可操作行为。

#### Strategy 策略模式

策略模式构建多个策略类用于封装不同的算法。需要调用算法的调用者将持有某个策略类引用，并将所需实现的功能委托给策略加以处理。策略类通常封装了复杂的功能实现，如排序算法可以策略模式分别实现快速排序、插入排序、冒泡排序、归并排序、选择排序、堆排序等，然后由需排序的列表持有排序策略类的引用并动态切换。

#### Visitor 访问者模式

访问者模式指在访问聚合对象中的元素时执行的附加操作。访问者模式见于编译器，在遍历抽象语法树以访问每个节点时，程序需要作类型检查、代码优化、算术表达式计算等操作。

#### Interpreter 解释器模式

使用文法或领域专用语言表述一段程序的实现逻辑，然后由解释器将文法转换成程序处理能力。解释器是编译器的一个子集，所以会使用组合模式生成抽象语法树，使用访问者模式在解释过程中附加后续操作。

#### 行为模式回顾

|模式|类比|
|:---:|:---:|
|中介者模式|多个部门之间相互关联，由统一的上游进行组织中台|
|模板方法模式|上层将方向，下层做实施；曹操锦囊“张李出战，乐将军守”，张辽等落实|
|迭代器模式|遍历列表或树的机制|
|职责链模式|消息在逐层传递的过程中，不同的层级会做出相应的处理|
|备完录模式|操作记录留底，并仅允许原有操作者进行访问|
|观察者模式|订阅通知，当通知被发布时会接收到消息|
|命令模式|下发命令，以达成逻辑周转|
|状态模式|根据审批状态、上下线状态管理活动的可操作行为|
|策略模式|实现同一件的不同方法；讨刘璋时，庞统有上、中、下三策，刘备取中策|
|访问者模式|遍历节点时执行附加操作|
|解释器模式|行动简化为约定的指令、密码、通信暗号|

### 模式关系图

![rbdp](rbdp.jpg)

### 面向对象设计原则

* OCP 开闭原则：由勃兰特·梅耶（Bertrand Meyer）提出于《面向对象软件构造》中提出，软件实体应当对扩展开放，对修改关闭。设计上，可以将变化的部分封装起来并支持替换，并与稳定的部分隔离开来。为了达成开闭原则，可借助观察者模式、模板方法模式、策略模式、代理模式、职责链模式。
* LSP 里氏替换原则：由里斯科夫（Liskov）女士在《数据抽象和层次》中提出，继承必须确保超类所拥有的性质在子类中仍然成立。通俗地讲，就是子类可以扩展父类的功能，但不能改变父类原有的功能。因此里氏替换原则是实现开闭原则的重要方式之一。
* SRP 单一职责原则：由罗伯特·C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》中提出，指一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。
* DIP 依赖倒置原则：由罗伯特·马丁（Robert C.Martin）提出，高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。通俗地讲，就是要面向接口编程，不要面向实现编程。
* ISP 接口隔离原则：由罗伯特·马丁（Robert C.Martin）提出，客户端不应该被迫依赖于它不使用的方法，或者说，一个类对另一个类的依赖应该建立在最小的接口上。通俗地讲，要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
* LSP 最少知识原则：也称为 LoD 迪米特法则，在《程序员修炼之道》有所提及，只与你的直接朋友（指当前对象的成员对象等）交谈，不跟“陌生人”说话。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。
* CRP 合成复用原则：又叫 CARP 组合/聚合复用原则，指在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。

### 参考

[Java设计模式：23种设计模式全面解析（超级详细）](http://c.biancheng.net/design_pattern/)
[图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/)