---
title: 算法分析点到
category:
  - 计算机科学
  - 算法
tags:
  - 计算机科学
  - 算法
keywords: 算法
abbrlink: 7396953c
date: 2020-06-07 00:00:00
updated: 2020-06-07 00:00:00
---

算法分析的逻辑线条比如自然科学中的经典方法：通过观察或实验收集数据；抽象简化的假设性模型；基于模型预测未来；通过实验数据核实并校准分析模型。这方面耳熟能详的先例有：牛顿爵士推演得来的万有引力定律仰赖于第谷、开普勒的数据；借助万有引力定律，科学家后来成功预测了海王星的存在。简单地说，这种经典方法在定性和定量分析中往复折返，基于定性分析推断第一、第二自变量，基于定量分析明确因变量和自变量的关系（甚或将自变量作为噪声剔除），然后回到定性分析中试验剩余的自变量，以此不断修正模型。这种经典方法本质上是机械性的。笔者不妨以薄弱的力量补充说明一下这种经典方法的局限性。杰拉尔德·温伯格在《系统化思维导论》中给出了一个较高的视角。他首先将系统分为三类：有序的、简单的系统（小数系统）；有序的、复杂的系统（中数系统）；无序的、复杂的系统（大数系统）。机械论（包含如上的经典方法）适用于解释有序的、简单的系统。对于无序的、复杂的系统，因其无序、随机性，这也就为统计手段（比如大数定律）提供了用武的可能，中数系统的典型即如热力学。但是有序的、复杂的系统既不方便精确计算，又不方便统计。对此，《系统化思维导论》中称“我们可以预计它（中数系统）与任何理论都或多或少地存在很大的波动“，“科学技术的哲学基础局限于小数系统和大数系统” 。

算法分析首先定性地将问题界定为运行时长和问题规模的关系。简单的算法样例如，给定一个数组，求任意三个元素相加之和为零的可能性。实现上，该算法需要将数组递归遍历三次。问题规模即为数组的长度 N。这一阶段的算法分析就是确定运行时长 T 与数组长度 N 之间的关系，即 T = f(N)。其方法在于不断改变数组长度 N，然后绘制运行时长与数组长度的曲线图。通过数学归纳法，我们得到三个元素相加的情形为 N(N - 1)(N - 2)/6 种。当 N 较大时，较低数量级的其他项相对较小。我们近似认为，T 与 N 的三次方成正比（T 与 N 的关系记为 T = ~f(N)，N 的三次方也称为增长数量级），也就是，lg(T) 与 lg(N) 成线性关系。lg(T) 与 lg(N) 成线性关系不止适用于数组递归遍历三次的情景，它也被称为幂次法则，即 T 与 N 的 m 次方 成正方，适用于解释很多自然和人工的现象。在算法分析方面，D.E.Knuth 更一般地指出运行时长取决于执行每条语句的耗时以及频率，执行每条语句的耗时取决于计算机性能，执行每条语句的频率即问题规模，总共执行了多少条指令。

最常见的增长数量级有：常数级别、lgN 对数级别、N 线性级别、N*lgN 线性对数级别、平方级别、立方级别、指数级别。比如解题空间在于数组，遍历两次，就构成平方级别的增长数量级；零次，就构成常数级别的增长数量级。如果使用二分策略处理数组（如二分查找），其算法就是对数级别的。如果使用分而后治的手段处理数组，即算法由线性级别算法及对数级别算法组合得来，那就是线性对数级别的。对于一段程序，直观地可以依据是否使用循环语句等判断其增长数量级。

算法所占用的内存与算法中所使用的数据类型息息相关。常见的数据结构有 Array 数组、Bag 背包、Queue 队列、Stack 栈、Linked List 链表、Tree 树、Graph 图、堆、Hash Table 散列表。这里只挑其中几种加以说明。背包指一种只允许塞入元素、不允许删除元素的集合类型，使用背包基于一种前提：通过迭代无差别的访问元素（如求平均值或方差）。队列是一种基于先进先出策略的集合类型；栈基于先进后出。链表以 Node 节点形式呈现，此一节点会持有彼一节点的引用。链表可用于实现背包、队列、栈。理解常见的数据结构有便于，使用这些基本数据结构对程序世界内在或外在的主客观实体建模。

```java
// 只进不出背包
public class Bag<Item> implements Iterable<Item> {
  Bag(){}
  void add(Item item);
  boolean isEmpty();
  int size();
}
// 先进先出队列
public class Queue<Item> implements Iterable<Item> {
  Queue(){}
  void enqueue(Item item);
  Item dequeue();
  boolean isEmpty();
  int size();
}
// 先进后出栈
public class Stack<Item> implements Iterable<Item> {
  Stack(){}
  void push(Item item);
  Item pop();
  boolean isEmpty();
  int size();
}
// 链表节点
public class Node {
  Item item;
  Node next;
}
```

接下来，笔者有意用只点明思路的方式概括常见的排序和查找算法。对于不太接触算法的程序员们，算法可视为一种有益头脑的锻炼。没法产生新思维的探究不见得能带来更多的收获，这样的话，遇到问题时现学现用也会是个可供考虑的选项。关于算法的详细内容可参考算法红宝书、[十大经典排序算法](https://www.cnblogs.com/onepixel/articles/7674659.html)、[七大查找算法](https://blog.csdn.net/weixin_39241397/article/details/79344179)。

常见的排序算法有以下几种：

* 冒泡排序：逐次比对相邻两元素，每次遍历完成后将数组中最大元素移到尾部。时间复杂度在平方级。
* 快速排序：逐次遍历集合，每次将集合中的最小值移动到遍历起始位（首次即头部）。时间复杂度在平方级。
* 插入排序：快速排序并没有有效的利用每次遍历前已排序的左侧元素，插入排序的演进思路基于此，即将待排序的元素插入到已排序的左侧元素中。时间复杂度最好在线性级，最差在平方级。
* 希尔排序：希尔排序的着眼点还是基于插入排序的缺点，插入排序面对反序数组不可避免需要逐项比较。其设想是通过插入排序法构建间隔有序的元素（比如数组内第 1、4、7 项有序，相应的 2、5、8 项与 3、6、9 项也分别有序），随着间隔递减至 1，整个数组也就完成了排序。希尔排序提升算法性能的规模并不直观，它的时间复杂度最好在线性级，最差在平方级。
* 归并排序：与希尔排序的间隔有序不同，归并排序是将数组拆分排序，无间隔。归并排序采用递归拆分数组再归并的方式，对整个数组进行排序。时间复杂度在线性对数级。
* 快速排序：设定基准点，将数组元素分别安插到基准点前或后，随后递归实现排序。时间复杂度在线性对数级，直观地看，它是递归采用两分法 lgN 与遍历 N 的乘积（归并排序也可以这样直观地看）。
* 堆排序：基于二叉堆的特性调换节点位置以实现排序。时间复杂度在线性对数级。
* 计数排序：遍历数组，将元素以键值对形式存入 map，然后回填到新的数组中。时间复杂度在线性级。
* 桶排序：遍历数组，将元素依次顺序填充到不同的桶中（将高位相同的分为1组，目的是减省内存消耗），在桶中完成小数组排序，然后回填到新的数组中。时间复杂度最好在线性级，最坏在平方级。
* 基数排序：基数排序和桶排序一样，都是为了减少计数排序的内存消耗。该算法先按低位收集元素并使低位有序，再按高位收集元素，以完成数组的整体排序。时间复杂度在线性级。

常见的查找算法有：

* 顺序查找：即遍历数组进行逐个比较。时间复杂度在线性级。
* 二分查找：即逐次取切分数组的中点进行比较判断。时间复杂度在对数级。
* 插值查找：介于二分查找的缺点并没有利用被查找项可能偏小或偏大的特点（偏小时，在左半部分查找更有效）。插值查找首先推算被查找项的可能位置，然后再进行查找。显然插值查找不大适用于无序数组。时间复杂度在对数级。
* 二叉树查找：预先构建二叉树，随后进行查找。